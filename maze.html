<!DOCTYPE html>
<html><body>
<script src="https://aframe.io/releases/0.3.0/aframe.min.js"></script>
<script src="../../dist/altspace.js"></script>a
<script src="https://sdk.altvr.com/libs/altspace.js/2.4.0/altspace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nunjucks/3.0.0/nunjucks.min.js"></script>
<script src="https://rawgit.com/ngokevin/kframe/a1df8fc01514e509ba6d39c964254a1f1043b12b/dist/kframe.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/4.6.2/firebase.js"></script>
<script>
  // Initialize Firebase
  var config = {
    apiKey: "AIzaSyCqHluXEqdILFNl22-DFOVsMBHNt2pZ5H4",
    authDomain: "vrmaze-b0810.firebaseapp.com",
    databaseURL: "https://vrmaze-b0810.firebaseio.com",
    projectId: "vrmaze-b0810",
    storageBucket: "vrmaze-b0810.appspot.com",
    messagingSenderId: "82215601878"
  };
  firebase.initializeApp(config);
</script>


<script>
var fbGameRef = new Firebase("https://vrmaze-b0810.firebaseio.com");
var started = false;
var time=0;
var finaltime=0;
var user;
var times=[];



var leaderBoard = [];//testing
//base collision aframe component code

getUser1();

AFRAME.registerComponent('base_collision',
                         {
  schema:  //does stuff
  { 
    jointCubeSize: {
      type: 'float',
      default: 0.275
    },
	box_id:
	{
		type: 'int'
	}
  },
  init: function ()
  {
    var self = this;
    var object = self.el.object3D;
	
    object.addBehavior(new altspace.utilities.behaviors.JointCollisionEvents
                       ({
      joints: [['Head', 'Center', 0]], jointCubeSize: self.data.jointCubeSize
    }));
	
	//joints enter
    object.addEventListener('jointcollisionenter', handleJoin);		
    function handleJoin(event)
    {
	
		console.log("box " + self.data.box_id);
	    //console.log("start");
		
		if (self.data.box_id===2 && started){
		
			//upload time to database
		
			
			finaltime = time;
			times[0] = user;
			times[1] = finaltime;
			console.log("final time = " + finaltime);
			writeFirebase();
			
			//readFBTimes();
		
			console.log("end");
			started = false;
		}	
		
		
		if (self.data.box_id === 1 && !started){
			time = 0;
			console.log("ticky");
			setInterval(tick, 100);
			
			document.querySelector('#pc-m').emit('m');
			document.querySelector('#gear-m').emit('m');
			
			started = true;
		}
		
		
		
		//readfirebase every second to see if updated maze...
	
		
	
		
		
    }// end function handle join
	
	//joint collision leave
    object.addEventListener('jointcollisionleave', handleLeave);
    function handleLeave(event)
    {
	
    }//end function handle leave
  }
}); //end base collision

function writeFirebase(){

	console.log("writing to firebase");
	fbGameRef.child("times").push({times:times});
	
	//readFirebase();
}


function tick(){

	time+=0.1;
	time = Math.round(time*10)/10;
	
	if (started){
		document.querySelector('#time').setAttribute('n-text','text:' + time);
	}
	else 
	{
		document.querySelector('#time').setAttribute('n-text','text:' + finaltime);
	}
	
	//readFirebase();
	//console.log(time);
	
}

function getUser1(){
	
	altspace.getUser().then(function(user1){
		user = user1.displayName;
		console.log(user);
		//sets timeout to deal with latency issues - kinda works
		//setTimeout(addToSession, 2000); 
	});
	
}

var test = [];
var counter = 0;
var top5_board = "";
var board = "";

function readFBTimes(){

	
	
	console.log("reading times...");
	fbGameRef.child("times").on("child_added", function(snapshot){
	
		leaderBoard = snapshot.val();
		test[counter] = leaderBoard;
		counter ++;
		console.log("counter" + counter);

	});

	/*
	//SOMETHING WRONG WITH THIS CODE
	//BUT NOT IMPORTANT
	fbGameRef.child("times").on("child_removed", function(snapshot){
	
		leaderBoard = snapshot.val();
		console.log(leaderBoard);
		console.log("test:"+ leaderBoard.length);
		
		if (leaderBoard.times.length != null){
			for (var i=0; i<leaderBoard.times.length;i++){
		
				test[i] = leaderBoard;
		
			}
		}
		
	});
	*/

	fbGameRef.on("value", function(snap) {
		console.log("promise over");
	
		updateLeaderboard();
	
	});
	
}

function updateLeaderboard(){

		board="";
		top5_board="";

		//console.log(test[1]);
		//console.log(counter);
	
		//SORT TEST TIMES
		sortTimes();
	
	//only display top 5 to big leaderboard
	for (var i=0; i<test.length;i++){
		console.log(test[i].times);
		board = board + "\n" + test[i].times;
		
		if (i < 5){
			top5_board = top5_board + "\n" + test[i].times;
		}
			
	}

	document.querySelector('#lb_top5').setAttribute('n-text','text:' + top5_board);
	document.querySelector('#leaderboard').setAttribute('n-text','text:' + board);

};

function sortTimes(){

	var swapped;

	do {
	swapped = false;
	for (var i=0; i<(test.length-1);i++){
		console.log("sorting");
		//bubble sort for now - should upgrade to quicksort for efficiency
		
		if (test[i].times[1] > test[i+1].times[1]){
			
			var temp = test[i];
			test[i] = test[i+1];
			test[i+1] = temp;
			swapped = true;
		}
				
	}//end for
	} while (swapped);
	
	for (var i =0; i<test.length;i++){
		console.log(test[i].times[1]);
	}
	
	
}


readFBTimes();


</script>










<!-- set up the scene -->
<a-scene altspace>
 
    <!-- add a view camera (2d only) -->
    <!--<a-text value="Hello, World!"></a-text>-->

    <a-assets>
		<img id="test" src="assets/test.png" />
		<img id="b1" src="assets/bush1.png" />
		<img id="b2" src="assets/bush2.png" />
		<img id="b3" src="assets/bush3.png" />
		<img id="b4" src="assets/bush4.png" />
		<img id="floor" src="assets/floor.png" />
  	</a-assets>

	<a-entity position='4 8 -6' rotation='0 0 0' n-text='text: Craigs Maze! ;'></a-entity>
	<a-entity id='time' scale="4 4 4" position='86 3 100' rotation='0 180 0' n-text='text: timer;'></a-entity>
	<a-entity id='lb_top5' scale="5 5 5" position='40 50 15' n-text='text: test;'>
		<a-animation attribute="rotation" dur="50000" easing="linear" to="0 360 0" repeat="indefinite"></a-animation>
	</a-entity>

	<a-entity id='leaderboard' scale="1 1 1" position='0 10 0' n-text='text: test;'></a-entity>
	
	 <a-sky radius="550" src="assets/falk.jpg" segments-width="10" segments-height="6"></a-sky>
		
	<a-box id="base1_collider" base_collision="box_id:1;" n-mesh-collider="type:hologram" color="white" position="10, 2, -1.5" rotation="0 0 0" scale="1 4 3" opacity="0.5" altspace-cursor-collider="enabled: false"></a-box> <!-- base1 collider -->	
	<a-box id="base2_collider" base_collision="box_id:2;" n-mesh-collider="type:hologram" color="red" position="56.5, 2, 45" rotation="0 90 0" scale="1 4 3" opacity="0.5" altspace-cursor-collider="enabled: false"></a-box> <!-- base1 collider -->	
	
	<a-entity id="pc-m" position='40 30 15' n-sound="on: m; src:https://greeny3ny.github.io/VRMaze/assets/bushes.ogg;"></a-entity>
	<a-entity id="gear-m" position='40 30 15' n-sound="on: m; src:https://greeny3ny.github.io/VRMaze/assets/bushes.mp3;"></a-entity>
	
		
</a-scene>
 
</body>

<script>
//this kinda works but messes stuff up 

altspace.getEnclosure().then(function(enclosure){
        enclosure.requestFullspace().then(function(){
				
		
var utilities = altspace.utilities;
var behaviors = altspace.utilities.behaviors;
var sim = new utilities.Simulation();
var inCodePen = utilities.codePen.inCodePen;
var instanceRef;
var scene = document.querySelector('a-scene');

var fbGameRef = new Firebase("https://vrmaze-b0810.firebaseio.com");
//---
var size = 16;
var scale = 3;
var height = 4;
var xShift = 10;
var maze = newMaze1(size,size);
var objects = [];
//console.log(maze);



var box1Geo = new THREE.BoxGeometry(1, 1, 1); 

var bTex = new THREE.ImageUtils.loadTexture("assets/test.png");
var bMat = new THREE.MeshBasicMaterial({ 
    map:bTex, 
    side:THREE.DoubleSide 
}); 


var newMaze = new THREE.Mesh(box1Geo, bMat);

var endbox = new THREE.Mesh(box1Geo, bMat);
//var box4 = new THREE.Mesh(box4Geo, bMat);

newMaze.position.set(-1, 0, -1);
endbox.position.set((scale*size), 5, (scale*size)-scale);
//box4.position.set(scale*size/2,0,-scale);

sim.scene.add(newMaze);
//sim.scene.add(endbox);



function wipeObjects(){

	for (var i=0; i<objects.length; i++){
		scene.remove(objects[i]);
	}

}



function readFirebase(){

	console.log("reading firebase...");
	fbGameRef.child("maze").on("value", function(snapshot){
		maze = snapshot.val();
		main();
	});

}


function writeFirebase(){

	console.log("writing to firebase");
	fbGameRef.update({maze:maze});
	
	//readFirebase();
}



//main();
//writeFirebase();
readFirebase();


function main(){


wipeObjects();




//console.log(maze);

var floor = document.createElement('a-box');
		floor.setAttribute('scale', scale*size + ' 0.1 ' +scale*size);
		floor.setAttribute('color','#00FF00');
		floor.setAttribute('n-mesh-collider','type:environment');
		floor.setAttribute('position', xShift + (scale*size)/2 + ' 0 ' + (scale*size-2*scale)/2);
		floor.setAttribute('src','#floor');
		
	scene.appendChild(floor);
	objects.push(floor);

	var roof = document.createElement('a-box');
		roof.setAttribute('scale', scale*size + ' 0.1 ' +scale*size);
		roof.setAttribute('opacity','0.25');
		roof.setAttribute('n-mesh-collider','type:environment');
		roof.setAttribute('position', xShift + (scale*size)/2 + ' '+height+' ' + (scale*size-2*scale)/2);

	scene.appendChild(roof);
	objects.push(roof);
	
	var ramp = document.createElement('a-box');
		//roof.setAttribute('geometry', 'primitive: box; width: '+scale*size+'; height:0.1; depth: '+scale*size+'; ');
		ramp.setAttribute('scale', height + ' 0.1 2');
		ramp.setAttribute('opacity','0.25');
		ramp.setAttribute('n-mesh-collider','type:environment');
		ramp.setAttribute('position', xShift + ' ' +height/2+' -4');
		ramp.setAttribute('rotation', '0 0 45');
		ramp.setAttribute('color','red');
		
	scene.appendChild(ramp);
	objects.push(ramp);

//side 1	
var box3 = document.createElement('a-box');
		box3.setAttribute('scale', '0.1 ' +height+ ' '+scale*size);
		box3.setAttribute('n-mesh-collider','type:environment');
		box3.setAttribute('position', xShift + scale*size + ' ' + height/2 + ' ' + (scale*size/2-scale));
		box3.setAttribute('src','#b1');
	
//side 2
var box4 = document.createElement('a-box');
		box4.setAttribute('scale', size*scale + ' ' +height+ ' 0.1');
		box4.setAttribute('n-mesh-collider','type:environment');
		box4.setAttribute('position', xShift + scale*size/2 + ' '+height/2+' ' + -scale);
		box4.setAttribute('src','#b1');
		
		scene.appendChild(box3);
		scene.appendChild(box4);
		
		objects.push(box3);
		objects.push(box4);
		

for (var i = 0; i<size;i++){
	for (var j = 0; j < size; j ++){
	
		maze[0][0][0] = 1; //enter
		maze[size-1][size-1][1]= 1; //exit

		/*
		var box1 = document.createElement('a-entity');
		box1.setAttribute('geometry', 'primitive: box; width: 0.1; height: '+height+'; depth: '+scale+';');
		box1.setAttribute('color','#00FF00');
		box1.setAttribute('n-mesh-collider','type:environment');
		box1.setAttribute('opacity','0.5');
		*/
			
		var bushRandom1 = Math.floor((Math.random() * 4) + 1);
		var bushRandom2 = Math.floor((Math.random() * 4) + 1);
			
		var box1 = document.createElement('a-box');
		box1.setAttribute('scale', '0.1 ' + height + ' ' + scale);
		box1.setAttribute('src','#b'+bushRandom1);
		box1.setAttribute('n-mesh-collider','type:environment');
		
		
		
		
		var box2 = document.createElement('a-box');
		box2.setAttribute('scale', scale+' ' + height + ' 0.1');
		box2.setAttribute('src','#b'+bushRandom2);
		box2.setAttribute('n-mesh-collider','type:environment');
		
		//box2.collider = true;
		
		//top boxes
		if (maze[i][j][0] === 0 ){
			//box1.position.set(scale*i,0,scale*(j-0.5));
			box1.setAttribute('position', xShift + scale*i + ' ' +height/2+' ' + scale*(j-0.5));
			//sim.scene.add(box1);
			scene.appendChild(box1);
			objects.push(box1);
		}
		if (maze[i][j][1] === 0 ){
			//box2.position.set(scale*(i+0.5),0,scale*j);
			box2.setAttribute('position', xShift + scale*(i+0.5) + ' '+height/2+' ' + scale*j);
			//sim.scene.add(box2);
			scene.appendChild(box2);
			objects.push(box2);
		}
		
	}
}
}//end main



//readFBTimes();




//not my code... 
function newMaze1(x, y) {

    // Establish variables and starting grid
    var totalCells = x*y;
	var cells = new Array();
    var unvis = new Array();
    for (var i = 0; i < y; i++) {
        cells[i] = new Array();
        unvis[i] = new Array();
        for (var j = 0; j < x; j++) {
            cells[i][j] = [0,0,0,0];
            unvis[i][j] = true;
        }
    }
    
    // Set a random position to start from
    var currentCell = [Math.floor(Math.random()*y), Math.floor(Math.random()*x)];
    var path = [currentCell];
    unvis[currentCell[0]][currentCell[1]] = false;
    var visited = 1;
    
    // Loop through all available cell positions
    while (visited < totalCells) {
        // Determine neighboring cells
        var pot = [[currentCell[0]-1, currentCell[1], 0, 2],
                [currentCell[0], currentCell[1]+1, 1, 3],
                [currentCell[0]+1, currentCell[1], 2, 0],
                [currentCell[0], currentCell[1]-1, 3, 1]];
        var neighbors = new Array();
        
        // Determine if each neighboring cell is in game grid, and whether it has already been checked
        for (var l = 0; l < 4; l++) {
            if (pot[l][0] > -1 && pot[l][0] < y && pot[l][1] > -1 && pot[l][1] < x && unvis[pot[l][0]][pot[l][1]]) { neighbors.push(pot[l]); }
        }
        
        // If at least one active neighboring cell has been found
        if (neighbors.length) {
            // Choose one of the neighbors at random
            next = neighbors[Math.floor(Math.random()*neighbors.length)];
            
            // Remove the wall between the current cell and the chosen neighboring cell
            cells[currentCell[0]][currentCell[1]][next[2]] = 1;
            cells[next[0]][next[1]][next[3]] = 1;
            
            // Mark the neighbor as visited, and set it as the current cell
            unvis[next[0]][next[1]] = false;
            visited++;
            currentCell = [next[0], next[1]];
            path.push(currentCell);
        }
        // Otherwise go back up a step and keep going
        else {
            currentCell = path.pop();
        }
    }
    return cells;
}

newMaze.addEventListener('cursordown', function(){
	//console.log("123");
	//console.log(newMaze1(size,size));
	maze = newMaze1(size,size);
	writeFirebase();
	
});


		});
   });
</script>
</html>
