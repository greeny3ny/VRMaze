<!DOCTYPE html>
<html><body>
<script src="https://aframe.io/releases/0.3.0/aframe.min.js"></script>
<script src="../../dist/altspace.js"></script>a
<script src="https://sdk.altvr.com/libs/altspace.js/2.4.0/altspace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nunjucks/3.0.0/nunjucks.min.js"></script>
<script src="https://rawgit.com/ngokevin/kframe/a1df8fc01514e509ba6d39c964254a1f1043b12b/dist/kframe.min.js"></script>


<script src="https://www.gstatic.com/firebasejs/4.6.2/firebase.js"></script>
<script>
  // Initialize Firebase
  var config = {
    apiKey: "AIzaSyCqHluXEqdILFNl22-DFOVsMBHNt2pZ5H4",
    authDomain: "vrmaze-b0810.firebaseapp.com",
    databaseURL: "https://vrmaze-b0810.firebaseio.com",
    projectId: "vrmaze-b0810",
    storageBucket: "vrmaze-b0810.appspot.com",
    messagingSenderId: "82215601878"
  };
  firebase.initializeApp(config);
</script>


<script>
var fbGameRef = new Firebase("https://vrmaze-b0810.firebaseio.com");
var started = false;
var time=0;
var finaltime=0;
var user;
var times=[];
//base collision aframe component code

getUser1();

AFRAME.registerComponent('base_collision',
                         {
  schema:  //does stuff
  { 
    jointCubeSize: {
      type: 'float',
      default: 0.275
    },
	box_id:
	{
		type: 'int'
	}
  },
  init: function ()
  {
    var self = this;
    var object = self.el.object3D;
	
    object.addBehavior(new altspace.utilities.behaviors.JointCollisionEvents
                       ({
      joints: [['Head', 'Center', 0]], jointCubeSize: self.data.jointCubeSize
    }));
	
	//joints enter
    object.addEventListener('jointcollisionenter', handleJoin);		
    function handleJoin(event)
    {
	
		console.log("box " + self.data.box_id);
	    //console.log("start");
		
		if (self.data.box_id==2 && started==true){
		
			//upload time to database
		
			
			finaltime = time;
			times[0] = user;
			times[1] = finaltime;
			console.log("final time = " + finaltime);
			writeFirebase();

		
			console.log("end");
			started = false;
		}	
		
		
		if (self.data.box_id == 1 && started==false){
		time = 0;
		console.log("ticky");
		setInterval(tick, 100);
		started = true;
		
		}
		
		
		
		//readfirebase every second to see if updated maze...
	
		
	
		
		
    }// end function handle join
	
	//joint collision leave
    object.addEventListener('jointcollisionleave', handleLeave);
    function handleLeave(event)
    {
	
    }//end function handle leave
  }
}); //end base collision

function writeFirebase(){

	console.log("writing to firebase");
	fbGameRef.child("times").push({times:times});
	
	//readFirebase();
}


function tick(){

	time+=0.1;
	time = Math.round(time*10)/10;
	
	if (started){
	document.querySelector('#time').setAttribute('n-text','text:' + time);
	}
	else 
	{
	document.querySelector('#time').setAttribute('n-text','text:' + finaltime);
	}
	
	//readFirebase();
	//console.log(time);
	
}

function getUser1(){
	
	altspace.getUser().then(function(user1){
		user = user1.displayName;
		console.log(user);
		//sets timeout to deal with latency issues - kinda works
		//setTimeout(addToSession, 2000); 
	});
	
}


</script>










<!-- set up the scene -->
<a-scene altspace>
 
    <!-- add a view camera (2d only) -->
    <!--<a-text value="Hello, World!"></a-text>-->

    <a-assets>

  	</a-assets>

	<a-entity position='4 8 -6' rotation='0 0 0' n-text='text: Craigs Maze! ;'></a-entity>
	<a-entity id='time' scale="4 4 4" position='86 3 100' rotation='0 180 0' n-text='text: timer;'></a-entity>

	 <a-sky radius="550" src="assets/falk.jpg" segments-width="10" segments-height="6">
		
		
		</a-sky>
		
	<!--<a-box id="test" col='boxId:1;' n-mesh-collider="type:hologram" position='0 0 0' scale='10 10 10' opacity='0.5' color='red'></a-box>
	-->
	
	<!--
	<a-box id="box" n-mesh-collider="type:hologram"; isTrigger=true;" col1="box_id:4;" color="red" position="0 0 0" scale="5 5 5" opacity="0.2">
	</a-box>
		
		-->
	<a-box id="base1_collider" base_collision="box_id:1;" n-mesh-collider="type:hologram" color="white" position="0, 2, -1.5" rotation="0 0 0" scale="1 4 3" opacity="0.5" altspace-cursor-collider="enabled: false"></a-box> <!-- base1 collider -->	
	<a-box id="base2_collider" base_collision="box_id:2;" n-mesh-collider="type:hologram" color="red" position="88.5, 2, 87" rotation="0 90 0" scale="1 4 3" opacity="0.5" altspace-cursor-collider="enabled: false"></a-box> <!-- base1 collider -->	
		
		
</a-scene>
 
</body>

<script>
//this kinda works but messes stuff up 

altspace.getEnclosure().then(function(enclosure){
        enclosure.requestFullspace().then(function(){
				
		
//--- synchronisation
var utilities = altspace.utilities;
var behaviors = altspace.utilities.behaviors;
//sync doesnt work yet :(
var sim = new utilities.Simulation();
var inCodePen = utilities.codePen.inCodePen;
var instanceRef;
var scene = document.querySelector('a-scene');

var fbGameRef = new Firebase("https://vrmaze-b0810.firebaseio.com");
//---
var size = 16;
var scale = 3;
var height = 4;
var xShift = 10;
var maze = newMaze1(size,size);
var objects = [];
//console.log(maze);

var box1Geo = new THREE.BoxGeometry(1, 1, 1); 

var bTex = new THREE.ImageUtils.loadTexture("assets/test.png");
var bMat = new THREE.MeshBasicMaterial({ 
    map:bTex, 
    side:THREE.DoubleSide 
}); 


var newMaze = new THREE.Mesh(box1Geo, bMat);

var endbox = new THREE.Mesh(box1Geo, bMat);
//var box4 = new THREE.Mesh(box4Geo, bMat);

newMaze.position.set(-1, 0, -1);
endbox.position.set((scale*size), 5, (scale*size)-scale);
//box4.position.set(scale*size/2,0,-scale);

sim.scene.add(newMaze);
//sim.scene.add(endbox);



function wipeObjects(){

	for (var i=0; i<objects.length; i++){
		scene.remove(objects[i]);
	}

}



function readFirebase(){

	console.log("reading firebase...");
	fbGameRef.child("maze").on("value", function(snapshot){
		maze = snapshot.val();
		main();
	});

}

function writeFirebase(){

	console.log("writing to firebase");
	fbGameRef.update({maze:maze});
	
	//readFirebase();
}



//main();
//writeFirebase();
readFirebase();


function main(){


wipeObjects();




//console.log(maze);

var floor = document.createElement('a-entity');
		floor.setAttribute('geometry', 'primitive: box; width: '+scale*size+'; height:0.1; depth: '+scale*size+';');
		floor.setAttribute('color','#00FF00');
		floor.setAttribute('n-mesh-collider','type:environment');
		floor.setAttribute('position', xShift + (scale*size)/2 + ' 0 ' + (scale*size-2*scale)/2);

	scene.appendChild(floor);
	objects.push(floor);

	var roof = document.createElement('a-box');
		//roof.setAttribute('geometry', 'primitive: box; width: '+scale*size+'; height:0.1; depth: '+scale*size+'; ');
		roof.setAttribute('scale', scale*size + ' 0.1 ' +scale*size);
		roof.setAttribute('opacity','0.25');
		roof.setAttribute('n-mesh-collider','type:environment');
		roof.setAttribute('position', xShift + (scale*size)/2 + ' '+height+' ' + (scale*size-2*scale)/2);

	scene.appendChild(roof);
	objects.push(roof);
	
	var ramp = document.createElement('a-box');
		//roof.setAttribute('geometry', 'primitive: box; width: '+scale*size+'; height:0.1; depth: '+scale*size+'; ');
		ramp.setAttribute('scale', height + ' 0.1 2');
		ramp.setAttribute('opacity','0.25');
		ramp.setAttribute('n-mesh-collider','type:environment');
		ramp.setAttribute('position', 'xShift '+height/2+' -4');
		ramp.setAttribute('rotation', '0 0 45');
		ramp.setAttribute('color','red');
		
	scene.appendChild(ramp);
	objects.push(ramp);






var box3 = document.createElement('a-entity');
		box3.setAttribute('geometry', 'primitive: box; width: 0.1; height: '+height+'; depth: '+(scale*size)+';');
		box3.setAttribute('color','#00FF00');
		box3.setAttribute('n-mesh-collider','type:environment');
		box3.setAttribute('position', xShift + scale*size + ' ' + height/2 + ' ' + (scale*size/2-scale));
		box3.setAttribute('opacity','0.5');
		
var box4 = document.createElement('a-entity');
		box4.setAttribute('geometry', 'primitive: box; width: '+ (size*scale) +'; height: '+height+'; depth: 0.1');
		box4.setAttribute('color','#00FF00');
		box4.setAttribute('n-mesh-collider','type:environment');
		box4.setAttribute('position', xShift + scale*size/2 + ' '+height/2+' ' + -scale);
		box4.setAttribute('opacity','0.5');
		
		scene.appendChild(box3);
		scene.appendChild(box4);
		
		objects.push(box3);
		objects.push(box4);
		

for (var i = 0; i<size;i++){
	for (var j = 0; j < size; j ++){
	
		maze[0][0][0] = 1; //enter
		maze[size-1][size-1][1]= 1; //exit
	
		//console.log(i+ ","+j+"| " + maze[i][j]);

		
		var box1 = document.createElement('a-entity');
		box1.setAttribute('geometry', 'primitive: box; width: 0.1; height: '+height+'; depth: '+scale+';');
		box1.setAttribute('color','#00FF00');
		box1.setAttribute('n-mesh-collider','type:environment');
		box1.setAttribute('opacity','0.5');
		
		var box2 = document.createElement('a-entity');
		box2.setAttribute('geometry', 'primitive: box; width: ' +scale+ '; height: '+height+'; depth: 0.1;');
		box2.setAttribute('color','#00FF00');
		box2.setAttribute('n-mesh-collider','type:environment');
		box2.setAttribute('opacity','0.5');
		
		
		//box2.collider = true;
		
		//top boxes
		if (maze[i][j][0] == 0 ){
			//box1.position.set(scale*i,0,scale*(j-0.5));
			box1.setAttribute('position', xShift + scale*i + ' ' +height/2+' ' + scale*(j-0.5));
			//sim.scene.add(box1);
			scene.appendChild(box1);
			objects.push(box1);
		}
		if (maze[i][j][1] == 0 ){
			//box2.position.set(scale*(i+0.5),0,scale*j);
			box2.setAttribute('position', xShift + scale*(i+0.5) + ' '+height/2+' ' + scale*j);
			//sim.scene.add(box2);
			scene.appendChild(box2);
			objects.push(box2);
		}
		
	}
}
}//end main






















//not my code... 
function newMaze1(x, y) {

    // Establish variables and starting grid
    var totalCells = x*y;
	var cells = new Array();
    var unvis = new Array();
    for (var i = 0; i < y; i++) {
        cells[i] = new Array();
        unvis[i] = new Array();
        for (var j = 0; j < x; j++) {
            cells[i][j] = [0,0,0,0];
            unvis[i][j] = true;
        }
    }
    
    // Set a random position to start from
    var currentCell = [Math.floor(Math.random()*y), Math.floor(Math.random()*x)];
    var path = [currentCell];
    unvis[currentCell[0]][currentCell[1]] = false;
    var visited = 1;
    
    // Loop through all available cell positions
    while (visited < totalCells) {
        // Determine neighboring cells
        var pot = [[currentCell[0]-1, currentCell[1], 0, 2],
                [currentCell[0], currentCell[1]+1, 1, 3],
                [currentCell[0]+1, currentCell[1], 2, 0],
                [currentCell[0], currentCell[1]-1, 3, 1]];
        var neighbors = new Array();
        
        // Determine if each neighboring cell is in game grid, and whether it has already been checked
        for (var l = 0; l < 4; l++) {
            if (pot[l][0] > -1 && pot[l][0] < y && pot[l][1] > -1 && pot[l][1] < x && unvis[pot[l][0]][pot[l][1]]) { neighbors.push(pot[l]); }
        }
        
        // If at least one active neighboring cell has been found
        if (neighbors.length) {
            // Choose one of the neighbors at random
            next = neighbors[Math.floor(Math.random()*neighbors.length)];
            
            // Remove the wall between the current cell and the chosen neighboring cell
            cells[currentCell[0]][currentCell[1]][next[2]] = 1;
            cells[next[0]][next[1]][next[3]] = 1;
            
            // Mark the neighbor as visited, and set it as the current cell
            unvis[next[0]][next[1]] = false;
            visited++;
            currentCell = [next[0], next[1]];
            path.push(currentCell);
        }
        // Otherwise go back up a step and keep going
        else {
            currentCell = path.pop();
        }
    }
    return cells;
}

newMaze.addEventListener('cursordown', function(){
	//console.log("123");
	//console.log(newMaze1(size,size));
	maze = newMaze1(size,size);
	writeFirebase();
	
});


		});
   });
</script>
</html>
